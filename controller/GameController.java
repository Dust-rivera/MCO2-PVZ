// package controller;

// /**
//  * Controller class that manages the interaction between the model and view
//  * @author Deveza, Jerry King 
//  * @author Rivera, Dustine Gian
//  * @version 3.0
//  */
// import model.*;
// import view.*;


// public class GameController implements GameViewListener {
//     // The game board model
//     private final Board board;
//     // The GUI view
//     private final GameView view;
//     // The player/user
//     private final User player;
//     // Currently selected plant type ("Sunflower", "Peashooter", etc.)
//     private String selectedPlant = "";

//     /**
//      * Initializes the controller, model, and view. Sets up the game.
//      */
//     public GameController() {
//         this.player = new User(); // Create a new player
//         this.board = new Board(player, 5, 9); // 5x9 board
//         //this.view = new GameView(5, 9, this); // 5x9 grid in the view, register controller as listener
//         updateSunDisplay(); // Show initial sun count
//     }

//     /**
//      * Handles tile clicks from the view. Places plants if possible.
//      * @param row Row index of clicked tile
//      * @param col Column index of clicked tile
//      */
//     @Override
//     public void onTileClicked(int row, int col) {
//         // Handle Sunflower placement
//         if (selectedPlant.equals("Sunflower")) {
//             // Check if player has enough sun and tile is empty
//             if (player.getSunCount() >= 50 && !board.getTile(row, col).isPlantOccupied()) {
//                 board.placePlant(row, col, new Sunflower(row, col)); // Place Sunflower
//                 view.updateTile(row, col, "S"); // Update view
//                 updateSunDisplay(); // Deduct sun and update display
//                 view.setMessage("Sunflower Planted at (" + (row + 1) + ", " + (col + 1) + ")");
//             } else {
//                 view.setMessage("Can't place Sunflower here or not enough sun.");
//             }
//         // Handle Peashooter placement
//         } else if (selectedPlant.equals("Peashooter")) {
//             if (player.getSunCount() >= 100 && !board.getTile(row, col).isPlantOccupied()) {
//                 board.placePlant(row, col, new Peashooter(row, col));
//                 view.updateTile(row, col, "P");
//                 updateSunDisplay();
//                 view.setMessage("Peashooter Planted at (" + (row + 1) + ", " + (col + 1) + ")");
//             } else {
//                 view.setMessage("Can't place Peashooter here or not enough sun.");
//             }
//         // Handle CherryBomb placement (logic commented out)
//         } else if (selectedPlant.equals("CherryBomb")) {
//             if (player.getSunCount() >= 150 && !board.getTile(row, col).isPlantOccupied()) {
//                 // CherryBomb logic would go here (currently commented out)
//                 player.buyPlant(150); // Deduct sun for CherryBomb
//                 updateSunDisplay();
//                 view.setMessage("CherryBomb exploded at (" + (row + 1) + ", " + (col + 1) + ")");
//             } else {
//                 view.setMessage("Can't place CherryBomb or not enough sun.");
//             }
//         }
//         // Reset selected plant after placement attempt
//         selectedPlant = "";
//     }

//     /**
//      * Handles plant selection from the view (e.g., Sunflower, Peashooter, or sun generation).
//      * @param plantType The type of plant selected
//      */
//     @Override
//     public void onPlantSelected(String plantType) {
//         // Special signal to generate sun (should not be called from view anymore)
//         if (plantType.equals("_generateSun")) {
//             // No-op: sun is now generated by Board every 24 seconds
//         } else {
//             this.selectedPlant = plantType; // Store selected plant for placement
//         }
//         view.setUnclaimedSun(board.getSunCount()); // Update unclaimed sun display
//     }

//     /**
//      * Handles the start of the game and each game tick (timer event).
//      * Updates board, collects sun, updates view, and checks for game end.
//      */
//     @Override
//     public void onStartGame() {
//         board.update(); // Advance game state (move zombies, plants act, etc.)
//         // Remove auto-collect: player.collectSun(board.getSunCount(), board);
//         String msg = board.getMessage();
//         if (msg != null && (msg.contains("damaged") || msg.contains("dead"))) {
//             view.setMessage(msg);
//             view.clearMessageAfterDelay(1000); // Clear after 1 second
//         }
//         updateSunDisplay(); // Update sun count
//         view.setUnclaimedSun(board.getSunCount()); // Update unclaimed sun display
//         updateZombies(); // Update zombie positions in view
//         updatePlants(); // Update plant positions in view
//         // Game end logic
//         if (!board.getRunning()) {
//             view.setMessage("GAME OVER! Zombies reached your house.");
//             view.stopAllTimers();
//         } else if (view.getTimeLeft() <= 0) {
//             view.setMessage("GAME WON!!!!!");
//             view.stopAllTimers();
//         }
//     }

//     /**
//      * Handles the claim sun button click.
//      */
//     @Override
//     public void onClaimSun() {
//         int unclaimed = board.getSunCount();
//         if (unclaimed > 0) {
//             player.collectSun(unclaimed, board);
//             updateSunDisplay();
//             view.setUnclaimedSun(board.getSunCount());
//             view.setMessage("Claimed " + (unclaimed * 25) + " sun!");
//         } else {
//             view.setMessage("No sun to claim!");
//         }
//     }

//     /**
//      * Updates the sun count display in the view.
//      */
//     private void updateSunDisplay() {
//         view.setSun(player.getSunCount());
//     }

//     /**
//      * Updates the zombie markers on the board in the view.
//      * Shows number of zombies per tile.
//      */
//     private void updateZombies() {
//         view.clearZombies(); // Remove all zombie markers
//         for (int r = 0; r < board.getRows(); r++) {
//             for (int c = 0; c < board.getCol(); c++) {
//                 Tile tile = board.getTile(r, c);
//                 int zombieCount = tile.getZombies().size();
//                 if (zombieCount > 0) {
//                     view.updateTile(r, c, "Z" + zombieCount); // Show zombie count
//                 }
//             }
//         }
//     }

//     /**
//      * Updates the plant markers on the board in the view.
//      * Shows S for Sunflower, P for Peashooter.
//      */
//     private void updatePlants() {
//         for (int r = 0; r < board.getRows(); r++) {
//             for (int c = 0; c < board.getCol(); c++) {
//                 Plant plant = board.getTile(r, c).getPlant();
//                 String currentText = view.getTileText(r, c);
//                 // Remove any S or P, but keep Z# if present
//                 String textWithoutPlant = currentText.replaceAll("[SP]", "").trim();
//                 if (plant == null || plant.isDead()) {
//                     view.updateTile(r, c, textWithoutPlant); // Only remove plant marker, keep zombies
//                 } else if (plant instanceof Sunflower) {
//                     view.updateTile(r, c, ("S" + textWithoutPlant).trim());
//                 } else if (plant instanceof Peashooter) {
//                     view.updateTile(r, c, ("P" + textWithoutPlant).trim());
//                 }
//             }
//         }
//     }
// }

package controller;
import javax.swing.Timer;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.ImageIcon;
import java.awt.Image;
import javax.swing.JLabel;
import javax.swing.JLayeredPane;

//import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionListener;
import model.Board;
import model.NormalZombie;
import model.User;
import model.Zombie;
import view.GameView;
import view.ShopListener;
import view.SunClickListener;

import java.util.ArrayList;
import java.util.Random;
import javax.sound.sampled.*;
import java.io.File;
import java.io.IOException;

public class GameController{

    User user = new User();

    Board board = new Board(user, 5, 9);

    GameView view = new GameView();

    public GameController(){
        playSound("view\\audio\\Background.wav");
        this.layers = view.getLayers();
        this.zombieList = new ArrayList<>();
        view.updateSunCounter(user.getSunCount());
        startSunDrop();
        startSpawningZombies();
        System.out.println(view.getHeight());

        JLabel sunflower = view.getSunflowerPack();
        JLabel peashooter = view.getPeashooterPack();
        JLabel cherry = view.getCherryPack();

        // ADDED MULTIPLE MOUSE MOTION LISTENERS FOR THE SHOP LISTENER  
        ShopListener shopListener = new ShopListener(sunflower, peashooter, cherry, view.getLayers(), this);
        sunflower.addMouseListener(shopListener);
        sunflower.addMouseMotionListener(shopListener);
        peashooter.addMouseListener(shopListener);
        peashooter.addMouseMotionListener(shopListener);
        cherry.addMouseListener(shopListener);
        cherry.addMouseMotionListener(shopListener);


        //board.getSunflowerPack();

        view.addMouseMotionListener(new MouseMotionListener() {

            @Override
            public void mouseMoved(MouseEvent e) {
                System.out.println("Mouse Position: X=" + e.getX() + ", Y=" + e.getY());
            }

            @Override
            public void mouseDragged(MouseEvent e) {
                // Optional: Track dragging too
                System.out.println("Dragging at X=" + e.getX() + ", Y=" + e.getY());
            }
        });
    }



    private void startSunDrop(){
        Timer startTimer = new Timer(board.getSUN_GENERATE_TIME(), e -> spawnSun());
        startTimer.start();
    }

    private void spawnSun(){
        ImageIcon sunIcon = new ImageIcon("view\\assets\\Sun.png"); // replace path
        Image scaled = sunIcon.getImage().getScaledInstance(70, 70, Image.SCALE_SMOOTH);
        sunIcon = new ImageIcon(scaled);

        JLabel sunLabel = new JLabel(sunIcon);
        Random random = new Random();
        int x = random.nextInt(view.getWidth());
        sunLabel.setBounds(x, 0, 70, 70);
        view.addSun(sunLabel);
        sunLabel.addMouseListener(new SunClickListener(sunLabel, this));

         Timer fallTimer = new Timer(100, new ActionListener() {
            int y = 0;
            int min = 100;
            int maxY = random.nextInt(550 - min) + min;
            @Override
            public void actionPerformed(ActionEvent e) {
                y += 5;
                if (y >= maxY) {
                    ((Timer)e.getSource()).stop();
                }
                sunLabel.setBounds(x, y, 70, 70);
            }
        });
        fallTimer.start();
    }

    public Board getBoard() {
        return board;
    }

    public GameView getView() {
        return view;
    }

    public User getUser() {
        return user;
    }

    private JLayeredPane layers;
    //private static int zombieCount;
    private Random random = new Random();
    private ArrayList<Zombie> zombieList;

    private void startSpawningZombies(){
        Timer startTimer = new Timer(1000, e -> spawnZombie());
        Timer Brains = new Timer(10000, e -> playWavFile("view\\audio\\Groan_brains1.wav"));
        startTimer.start();
        Brains.start();
    }
    public void spawnZombie() {
        ImageIcon zombieIcon = new ImageIcon("view\\gifs\\Flag1.gif");
        // Image scaled = zombieIcon.getImage();//.getScaledInstance(70, 70, Image.SCALE_SMOOTH);
        // zombieIcon = new ImageIcon(scaled);

        JLabel zombieLabel = new JLabel(zombieIcon);
        int yCoordinate;
        switch(random.nextInt(5)) {
            case 0:
                yCoordinate = 75;
                break;
            case 1:
                yCoordinate = 170;
                break;
            case 2:
                yCoordinate = 260;
                break;
            case 3:
                yCoordinate = 350;
                break;
            case 4:
                yCoordinate = 440;
                break;
            default:
                yCoordinate = 0;
                break;
        }

        int startX = 800;
        zombieLabel.setBounds(startX, yCoordinate,zombieIcon.getIconWidth(), zombieIcon.getIconHeight());
        view.addZombie(zombieLabel);
        zombieList.add(new NormalZombie());

        Timer zombieWalking = new Timer(30, new ActionListener() {
            int x = startX;

            @Override
            public void actionPerformed(ActionEvent e){
                x -= .2;
                if (x < -100) {
                    ((Timer)e.getSource()).stop();
                }
                zombieLabel.setBounds(x, yCoordinate, zombieIcon.getIconWidth(), zombieIcon.getIconHeight());

               
                int boardX = 110;
                int boardY = 100;
                int tileWidth = 77;  
                int tileHeight = 90; 
                int zombieX = (int)x - boardX;
                int zombieY = yCoordinate + 100 - boardY;
                int col = zombieX / tileWidth;
                int row = zombieY / tileHeight;
                if (row >= 0 && row < 5 && col >= 0 && col < 9) {
                    int displayCol = col + 1;
                    int displayRow = row + 1;
                    System.out.println("Zombie is on tile: (" + displayCol + "," + displayRow + ")");
                }
            }
        });
        zombieWalking.start();
    }

    public void playWavFile(String filePath) {
        try {
            // Get the audio file
            File audioFile = new File(filePath);
            AudioInputStream audioStream = AudioSystem.getAudioInputStream(audioFile);
            
            // Get audio format
            AudioFormat format = audioStream.getFormat();
            
            // Create data line info
            DataLine.Info info = new DataLine.Info(Clip.class, format);
            
            // Check if system supports the data line
            if (!AudioSystem.isLineSupported(info)) {
                System.out.println("Line not supported");
                return;
            }
            
            // Get and open data line
            Clip audioClip = (Clip) AudioSystem.getLine(info);
            audioClip.open(audioStream);
            
            // Start playing
            audioClip.start();
            
            // Optional: Wait for the sound to finish
            // audioClip.drain();
            
        } catch (UnsupportedAudioFileException | IOException | LineUnavailableException e) {
            e.printStackTrace();
        }
    }

    public void playSound(String filePath) {
        try {
            Clip clip = AudioSystem.getClip();
            clip.open(AudioSystem.getAudioInputStream(new File(filePath)));
            clip.start();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
